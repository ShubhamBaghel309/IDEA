import os
import uvicorn
from fastapi import FastAPI, File, UploadFile, Form, HTTPException
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from dotenv import load_dotenv
import logging
import io

# Import our AssignmentChecker
from AssignmentChecker import AssignmentChecker

# Import plagiarism detection
from assistant.core.plagiarism import calculate_plagiarism, analyze_ai_content, extract_text_from_docx, read_text_file

# Load environment variables
load_dotenv()

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize AssignmentChecker with vector database
checker = AssignmentChecker(vector_db_dir="./vector_db")

# Initialize FastAPI
app = FastAPI(title="AI Teacher Assistant API")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Update for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define API models
class TextAssignmentRequest(BaseModel):
    student_name: str
    question: str
    answer: str
    reference_material: Optional[str] = ""

class PlagiarismResult(BaseModel):
    score: float
    ai_generated: bool
    ai_analysis: Dict[str, Any]
    similarity_scores: List[float] = []

class AssignmentResponse(BaseModel):
    student_name: str
    grade: str
    feedback: str
    analysis: Optional[str] = None
    document_id: Optional[str] = None
    file_id: Optional[str] = None
    plagiarism: Optional[PlagiarismResult] = None
    success: bool

@app.post("/check-text-assignment", response_model=AssignmentResponse)
async def check_text_assignment(request: TextAssignmentRequest):
    """
    Check a text-based assignment submission.
    """
    logger.info(f"Checking text assignment for student: {request.student_name}")
    
    try:
        # Step 1: Check for plagiarism and AI-generated content
        answer_text = request.answer
        
        # Create knowledge base from reference material if available
        knowledge_base_texts = []
        if request.reference_material:
            knowledge_base_texts.append(request.reference_material)
        
        # Get AI content analysis first (includes perplexity and burstiness)
        ai_analysis = analyze_ai_content(answer_text)
        ai_result_text = ai_analysis['result']
        
        # Now calculate plagiarism score (which also uses perplexity)
        plagiarism_score, similarity_scores = calculate_plagiarism(answer_text, knowledge_base_texts)
        
        # Determine if AI-generated based on both result text AND score threshold
        is_ai_generated = ai_result_text.startswith('AI Generated') and plagiarism_score > 40
        
        # Create plagiarism result
        plagiarism_result = PlagiarismResult(
            score=plagiarism_score,
            ai_generated=is_ai_generated,
            ai_analysis=ai_analysis,
            similarity_scores=similarity_scores
        )
        
        logger.info(f"Plagiarism score: {plagiarism_score:.2f}%, AI-generated: {is_ai_generated}")
        
        # Step 2: Only proceed with assignment checking if not flagged as AI-generated with high plagiarism
        if is_ai_generated and plagiarism_score > 75:
            # For highly suspicious content, return early with a warning
            return AssignmentResponse(
                student_name=request.student_name,
                grade="Failed",
                feedback="This submission appears to be generated by AI tools or contains significant plagiarism. Our analysis indicates unusual language patterns. Please submit original work.",
                analysis="Automatic grading skipped due to academic integrity concerns. The text demonstrates unusual perplexity and burstiness patterns consistent with AI-generated text.",
                plagiarism=plagiarism_result,
                success=False
            )
        
        # Step 3: Proceed with normal assignment checking
        result = checker.check_assignment(
            question=request.question,
            student_answer=request.answer,
            student_name=request.student_name,
            reference_material=request.reference_material
        )
        
        # Step 4: Return combined results
        return AssignmentResponse(
            student_name=request.student_name,
            grade=result["grade"],
            feedback=result["feedback"],
            analysis=result.get("analysis", ""),
            document_id=result.get("document_id", ""),
            plagiarism=plagiarism_result,
            success=result.get("success", True)
        )
    
    except Exception as e:
        logger.error(f"Error checking assignment: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error checking assignment: {str(e)}")

@app.post("/check-pdf-assignment", response_model=AssignmentResponse)
async def check_pdf_assignment(
    student_name: str = Form(...),
    assignment_prompt: str = Form(...),  # Changed from "assignment_instructions"
    reference_material: str = Form(""),
    pdf_file: UploadFile = File(...)
):
    """
    Check an assignment submitted as a PDF file.
    """
    if not pdf_file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="File must be a PDF")
    
    logger.info(f"Checking PDF assignment for student: {student_name}")
    
    try:
        # Step 1: Process the PDF file
        file_contents = await pdf_file.read()
        file_bytes = io.BytesIO(file_contents)
        
        # Extract text for plagiarism check
        from PyPDF2 import PdfReader
        reader = PdfReader(file_bytes)
        extracted_text = ""
        for page in reader.pages:
            extracted_text += page.extract_text()
        
        # Reset file pointer for assignment checker
        file_bytes.seek(0)
        
        # Step 2: Check for plagiarism and AI-generated content
        knowledge_base_texts = []
        if reference_material:
            knowledge_base_texts.append(reference_material)
        
        # Get AI content analysis first (includes perplexity and burstiness)
        ai_analysis = analyze_ai_content(extracted_text)
        ai_result_text = ai_analysis['result']
        
        # Now calculate plagiarism score (which also uses perplexity)
        plagiarism_score, similarity_scores = calculate_plagiarism(extracted_text, knowledge_base_texts)
        
        # Determine if AI-generated based on both result text AND score threshold
        is_ai_generated = ai_result_text.startswith('AI Generated') and plagiarism_score > 40
        
        # Create plagiarism result
        plagiarism_result = PlagiarismResult(
            score=plagiarism_score,
            ai_generated=is_ai_generated,
            ai_analysis=ai_analysis,
            similarity_scores=similarity_scores
        )
        
        logger.info(f"Plagiarism score: {plagiarism_score:.2f}%, AI-generated: {is_ai_generated}")
        
        # Step 3: Only proceed with assignment checking if not flagged as AI-generated with high plagiarism
        if is_ai_generated and plagiarism_score > 75:
            # For highly suspicious content, return early with a warning
            return AssignmentResponse(
                student_name=student_name,
                grade="Failed",
                feedback="This submission appears to be generated by AI tools or contains significant plagiarism. Our analysis indicates unusual language patterns. Please submit original work.",
                analysis="Automatic grading skipped due to academic integrity concerns. The text demonstrates unusual perplexity and burstiness patterns consistent with AI-generated text.",
                plagiarism=plagiarism_result,
                success=False
            )
        
        # Step 4: Proceed with normal assignment checking
        result = checker.check_pdf_assignment(
            pdf_file=file_bytes,
            assignment_prompt=assignment_prompt,  # Updated parameter name
            student_name=student_name,
            reference_material=reference_material
        )
        
        # Step 5: Return combined results
        return AssignmentResponse(
            student_name=student_name,
            grade=result["grade"],
            feedback=result["feedback"],
            analysis=result.get("analysis", ""),
            document_id=result.get("document_id", ""),
            file_id=result.get("file_id", ""),
            plagiarism=plagiarism_result,
            success=result.get("success", True)
        )
    
    except Exception as e:
        logger.error(f"Error checking PDF assignment: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error checking PDF assignment: {str(e)}")

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "vector_db": "connected"}

if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)